# coding: utf-8

"""
    Insight Sentinel API

    API to control beamforming on a Insight Sentinel device  # noqa: E501

    OpenAPI spec version: 0.0.0
    Contact: jonathan@insightacoustics.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from sentinel_client_elta.api_client import ApiClient


class DefaultApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def delay_microphone(self, **kwargs):  # noqa: E501
        """Set the microphone delay for a given microphone in the selected beam  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delay_microphone(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int beam_id: the beam to control. Should be a number between 0 and 7
        :param int mic_id: the microphone to control in the beam
        :param int mic_delay: the delay for the microphone
        :return: float
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delay_microphone_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.delay_microphone_with_http_info(**kwargs)  # noqa: E501
            return data

    def delay_microphone_with_http_info(self, **kwargs):  # noqa: E501
        """Set the microphone delay for a given microphone in the selected beam  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delay_microphone_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int beam_id: the beam to control. Should be a number between 0 and 7
        :param int mic_id: the microphone to control in the beam
        :param int mic_delay: the delay for the microphone
        :return: float
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['beam_id', 'mic_id', 'mic_delay']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delay_microphone" % key
                )
            params[key] = val
        del params['kwargs']

        if 'beam_id' in params and params['beam_id'] > 7:  # noqa: E501
            raise ValueError("Invalid value for parameter `beam_id` when calling `delay_microphone`, must be a value less than or equal to `7`")  # noqa: E501
        if 'beam_id' in params and params['beam_id'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `beam_id` when calling `delay_microphone`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'mic_id' in params and params['mic_id'] > 63:  # noqa: E501
            raise ValueError("Invalid value for parameter `mic_id` when calling `delay_microphone`, must be a value less than or equal to `63`")  # noqa: E501
        if 'mic_id' in params and params['mic_id'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `mic_id` when calling `delay_microphone`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'mic_delay' in params and params['mic_delay'] > 8191:  # noqa: E501
            raise ValueError("Invalid value for parameter `mic_delay` when calling `delay_microphone`, must be a value less than or equal to `8191`")  # noqa: E501
        if 'mic_delay' in params and params['mic_delay'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `mic_delay` when calling `delay_microphone`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'beam_id' in params:
            query_params.append(('beam_id', params['beam_id']))  # noqa: E501
        if 'mic_id' in params:
            query_params.append(('mic_id', params['mic_id']))  # noqa: E501
        if 'mic_delay' in params:
            query_params.append(('mic_delay', params['mic_delay']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/beamforming/delay_mic', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='float',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def enable_microphone(self, **kwargs):  # noqa: E501
        """Enable or disable selected microphone in the beam  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_microphone(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int beam_id: the beam to control. Should be a number between 0 and 7
        :param int mic_id: the microphone to control in the beam
        :param bool mic_state: the state of the microphone enabled/disabled
        :return: bool
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.enable_microphone_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.enable_microphone_with_http_info(**kwargs)  # noqa: E501
            return data

    def enable_microphone_with_http_info(self, **kwargs):  # noqa: E501
        """Enable or disable selected microphone in the beam  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_microphone_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int beam_id: the beam to control. Should be a number between 0 and 7
        :param int mic_id: the microphone to control in the beam
        :param bool mic_state: the state of the microphone enabled/disabled
        :return: bool
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['beam_id', 'mic_id', 'mic_state']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method enable_microphone" % key
                )
            params[key] = val
        del params['kwargs']

        if 'beam_id' in params and params['beam_id'] > 7:  # noqa: E501
            raise ValueError("Invalid value for parameter `beam_id` when calling `enable_microphone`, must be a value less than or equal to `7`")  # noqa: E501
        if 'beam_id' in params and params['beam_id'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `beam_id` when calling `enable_microphone`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'mic_id' in params and params['mic_id'] > 63:  # noqa: E501
            raise ValueError("Invalid value for parameter `mic_id` when calling `enable_microphone`, must be a value less than or equal to `63`")  # noqa: E501
        if 'mic_id' in params and params['mic_id'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `mic_id` when calling `enable_microphone`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'beam_id' in params:
            query_params.append(('beam_id', params['beam_id']))  # noqa: E501
        if 'mic_id' in params:
            query_params.append(('mic_id', params['mic_id']))  # noqa: E501
        if 'mic_state' in params:
            query_params.append(('mic_state', params['mic_state']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/beamforming/enable_mic', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='bool',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_array_config(self, **kwargs):  # noqa: E501
        """Gets the array geometry and attibutes  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_array_config(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_array_config_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_array_config_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_array_config_with_http_info(self, **kwargs):  # noqa: E501
        """Gets the array geometry and attibutes  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_array_config_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_array_config" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/beamforming/get_array_config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_state(self, **kwargs):  # noqa: E501
        """get the device state  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_state(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: DeviceState
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_state_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_device_state_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_device_state_with_http_info(self, **kwargs):  # noqa: E501
        """get the device state  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_state_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: DeviceState
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_state" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/get_device_state', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeviceState',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_gps(self, **kwargs):  # noqa: E501
        """Get the device gps position  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_gps(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: Gps
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_gps_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_gps_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_gps_with_http_info(self, **kwargs):  # noqa: E501
        """Get the device gps position  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_gps_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: Gps
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_gps" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/beamforming/get_gps', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Gps',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_network_configuration(self, **kwargs):  # noqa: E501
        """Sets the network configuration of the device  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_network_configuration(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: NetworkConfiguration
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_network_configuration_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_network_configuration_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_network_configuration_with_http_info(self, **kwargs):  # noqa: E501
        """Sets the network configuration of the device  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_network_configuration_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: NetworkConfiguration
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_network_configuration" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/get_network_configuration', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NetworkConfiguration',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_state(self, **kwargs):  # noqa: E501
        """Get the beamformer state (delays, gains, microphones enabled)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int beam_id: the beam to control. Should be a number between 0 and 7
        :return: BeamformerState
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_state_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_state_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_state_with_http_info(self, **kwargs):  # noqa: E501
        """Get the beamformer state (delays, gains, microphones enabled)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int beam_id: the beam to control. Should be a number between 0 and 7
        :return: BeamformerState
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['beam_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_state" % key
                )
            params[key] = val
        del params['kwargs']

        if 'beam_id' in params and params['beam_id'] > 7:  # noqa: E501
            raise ValueError("Invalid value for parameter `beam_id` when calling `get_state`, must be a value less than or equal to `7`")  # noqa: E501
        if 'beam_id' in params and params['beam_id'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `beam_id` when calling `get_state`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'beam_id' in params:
            query_params.append(('beam_id', params['beam_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/beamforming/get_state', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BeamformerState',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def neg_microphone(self, **kwargs):  # noqa: E501
        """Negatee selected microphone in the beam  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.neg_microphone(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int beam_id: the beam to control. Should be a number between 0 and 7
        :param int mic_id: the microphone to control in the beam
        :param bool mic_state: the state of the microphone negate/not_negate
        :return: bool
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.neg_microphone_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.neg_microphone_with_http_info(**kwargs)  # noqa: E501
            return data

    def neg_microphone_with_http_info(self, **kwargs):  # noqa: E501
        """Negatee selected microphone in the beam  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.neg_microphone_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int beam_id: the beam to control. Should be a number between 0 and 7
        :param int mic_id: the microphone to control in the beam
        :param bool mic_state: the state of the microphone negate/not_negate
        :return: bool
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['beam_id', 'mic_id', 'mic_state']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method neg_microphone" % key
                )
            params[key] = val
        del params['kwargs']

        if 'beam_id' in params and params['beam_id'] > 7:  # noqa: E501
            raise ValueError("Invalid value for parameter `beam_id` when calling `neg_microphone`, must be a value less than or equal to `7`")  # noqa: E501
        if 'beam_id' in params and params['beam_id'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `beam_id` when calling `neg_microphone`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'mic_id' in params and params['mic_id'] > 63:  # noqa: E501
            raise ValueError("Invalid value for parameter `mic_id` when calling `neg_microphone`, must be a value less than or equal to `63`")  # noqa: E501
        if 'mic_id' in params and params['mic_id'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `mic_id` when calling `neg_microphone`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'beam_id' in params:
            query_params.append(('beam_id', params['beam_id']))  # noqa: E501
        if 'mic_id' in params:
            query_params.append(('mic_id', params['mic_id']))  # noqa: E501
        if 'mic_state' in params:
            query_params.append(('mic_state', params['mic_state']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/beamforming/neg_mic', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='bool',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def reboot_device(self, **kwargs):  # noqa: E501
        """reboots the device  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reboot_device(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.reboot_device_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.reboot_device_with_http_info(**kwargs)  # noqa: E501
            return data

    def reboot_device_with_http_info(self, **kwargs):  # noqa: E501
        """reboots the device  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reboot_device_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method reboot_device" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/reboot_device', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def restart_streamer(self, **kwargs):  # noqa: E501
        """restart the streaming service on the device  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.restart_streamer(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.restart_streamer_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.restart_streamer_with_http_info(**kwargs)  # noqa: E501
            return data

    def restart_streamer_with_http_info(self, **kwargs):  # noqa: E501
        """restart the streaming service on the device  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.restart_streamer_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method restart_streamer" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/restart_streaming', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_audio_quality(self, quality_level, **kwargs):  # noqa: E501
        """set the device audio quality, 0 is high, 3 is low  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_audio_quality(quality_level, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int quality_level: audio quality to set, lower is better (required)
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_audio_quality_with_http_info(quality_level, **kwargs)  # noqa: E501
        else:
            (data) = self.set_audio_quality_with_http_info(quality_level, **kwargs)  # noqa: E501
            return data

    def set_audio_quality_with_http_info(self, quality_level, **kwargs):  # noqa: E501
        """set the device audio quality, 0 is high, 3 is low  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_audio_quality_with_http_info(quality_level, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int quality_level: audio quality to set, lower is better (required)
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['quality_level']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_audio_quality" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'quality_level' is set
        if ('quality_level' not in params or
                params['quality_level'] is None):
            raise ValueError("Missing the required parameter `quality_level` when calling `set_audio_quality`")  # noqa: E501

        if 'quality_level' in params and params['quality_level'] > 3:  # noqa: E501
            raise ValueError("Invalid value for parameter `quality_level` when calling `set_audio_quality`, must be a value less than or equal to `3`")  # noqa: E501
        if 'quality_level' in params and params['quality_level'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `quality_level` when calling `set_audio_quality`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'quality_level' in params:
            query_params.append(('quality_level', params['quality_level']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/set_audio_quality', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='int',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_beam_all_mics(self, beam_id, **kwargs):  # noqa: E501
        """Set the beamformer to use all microphones  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_beam_all_mics(beam_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int beam_id: the beam to control. Should be a number between 0 and 7 (required)
        :return: bool
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_beam_all_mics_with_http_info(beam_id, **kwargs)  # noqa: E501
        else:
            (data) = self.set_beam_all_mics_with_http_info(beam_id, **kwargs)  # noqa: E501
            return data

    def set_beam_all_mics_with_http_info(self, beam_id, **kwargs):  # noqa: E501
        """Set the beamformer to use all microphones  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_beam_all_mics_with_http_info(beam_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int beam_id: the beam to control. Should be a number between 0 and 7 (required)
        :return: bool
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['beam_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_beam_all_mics" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'beam_id' is set
        if ('beam_id' not in params or
                params['beam_id'] is None):
            raise ValueError("Missing the required parameter `beam_id` when calling `set_beam_all_mics`")  # noqa: E501

        if 'beam_id' in params and params['beam_id'] > 7:  # noqa: E501
            raise ValueError("Invalid value for parameter `beam_id` when calling `set_beam_all_mics`, must be a value less than or equal to `7`")  # noqa: E501
        if 'beam_id' in params and params['beam_id'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `beam_id` when calling `set_beam_all_mics`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'beam_id' in params:
            query_params.append(('beam_id', params['beam_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/beamforming/set_beam_all_mics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='bool',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_beam_direction(self, **kwargs):  # noqa: E501
        """Set the direction of the beam for the selected beam  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_beam_direction(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int beam_id: the beam to control. Should be a number between 0 and 7
        :param float phi: sets the phi angle in degree for the beam direction
        :param float theta: sets the theta angle in degree for the beam direction
        :return: list[float]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_beam_direction_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.set_beam_direction_with_http_info(**kwargs)  # noqa: E501
            return data

    def set_beam_direction_with_http_info(self, **kwargs):  # noqa: E501
        """Set the direction of the beam for the selected beam  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_beam_direction_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int beam_id: the beam to control. Should be a number between 0 and 7
        :param float phi: sets the phi angle in degree for the beam direction
        :param float theta: sets the theta angle in degree for the beam direction
        :return: list[float]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['beam_id', 'phi', 'theta']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_beam_direction" % key
                )
            params[key] = val
        del params['kwargs']

        if 'beam_id' in params and params['beam_id'] > 7:  # noqa: E501
            raise ValueError("Invalid value for parameter `beam_id` when calling `set_beam_direction`, must be a value less than or equal to `7`")  # noqa: E501
        if 'beam_id' in params and params['beam_id'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `beam_id` when calling `set_beam_direction`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'phi' in params and params['phi'] > 180:  # noqa: E501
            raise ValueError("Invalid value for parameter `phi` when calling `set_beam_direction`, must be a value less than or equal to `180`")  # noqa: E501
        if 'phi' in params and params['phi'] < -180:  # noqa: E501
            raise ValueError("Invalid value for parameter `phi` when calling `set_beam_direction`, must be a value greater than or equal to `-180`")  # noqa: E501
        if 'theta' in params and params['theta'] > 180:  # noqa: E501
            raise ValueError("Invalid value for parameter `theta` when calling `set_beam_direction`, must be a value less than or equal to `180`")  # noqa: E501
        if 'theta' in params and params['theta'] < -180:  # noqa: E501
            raise ValueError("Invalid value for parameter `theta` when calling `set_beam_direction`, must be a value greater than or equal to `-180`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'beam_id' in params:
            query_params.append(('beam_id', params['beam_id']))  # noqa: E501
        if 'phi' in params:
            query_params.append(('phi', params['phi']))  # noqa: E501
        if 'theta' in params:
            query_params.append(('theta', params['theta']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/beamforming/set_direction', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[float]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_beam_gain(self, **kwargs):  # noqa: E501
        """Set the gain of the beam for the selected beam  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_beam_gain(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int beam_id: the beam to control. Should be a number between 0 and 7
        :param int gain: sets the gain for the selected beam
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_beam_gain_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.set_beam_gain_with_http_info(**kwargs)  # noqa: E501
            return data

    def set_beam_gain_with_http_info(self, **kwargs):  # noqa: E501
        """Set the gain of the beam for the selected beam  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_beam_gain_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int beam_id: the beam to control. Should be a number between 0 and 7
        :param int gain: sets the gain for the selected beam
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['beam_id', 'gain']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_beam_gain" % key
                )
            params[key] = val
        del params['kwargs']

        if 'beam_id' in params and params['beam_id'] > 7:  # noqa: E501
            raise ValueError("Invalid value for parameter `beam_id` when calling `set_beam_gain`, must be a value less than or equal to `7`")  # noqa: E501
        if 'beam_id' in params and params['beam_id'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `beam_id` when calling `set_beam_gain`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'gain' in params and params['gain'] > 65535:  # noqa: E501
            raise ValueError("Invalid value for parameter `gain` when calling `set_beam_gain`, must be a value less than or equal to `65535`")  # noqa: E501
        if 'gain' in params and params['gain'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `gain` when calling `set_beam_gain`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'beam_id' in params:
            query_params.append(('beam_id', params['beam_id']))  # noqa: E501
        if 'gain' in params:
            query_params.append(('gain', params['gain']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/beamforming/set_gain', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='int',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_beam_single_mic(self, beam_id, mic_id, **kwargs):  # noqa: E501
        """Sets the beam to be a single microphone  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_beam_single_mic(beam_id, mic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int beam_id: the beam to control. Should be a number between 0 and 7 (required)
        :param int mic_id: the mic index for the mic to enable. Should be a number between 0 and 49 (required)
        :return: bool
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_beam_single_mic_with_http_info(beam_id, mic_id, **kwargs)  # noqa: E501
        else:
            (data) = self.set_beam_single_mic_with_http_info(beam_id, mic_id, **kwargs)  # noqa: E501
            return data

    def set_beam_single_mic_with_http_info(self, beam_id, mic_id, **kwargs):  # noqa: E501
        """Sets the beam to be a single microphone  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_beam_single_mic_with_http_info(beam_id, mic_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int beam_id: the beam to control. Should be a number between 0 and 7 (required)
        :param int mic_id: the mic index for the mic to enable. Should be a number between 0 and 49 (required)
        :return: bool
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['beam_id', 'mic_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_beam_single_mic" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'beam_id' is set
        if ('beam_id' not in params or
                params['beam_id'] is None):
            raise ValueError("Missing the required parameter `beam_id` when calling `set_beam_single_mic`")  # noqa: E501
        # verify the required parameter 'mic_id' is set
        if ('mic_id' not in params or
                params['mic_id'] is None):
            raise ValueError("Missing the required parameter `mic_id` when calling `set_beam_single_mic`")  # noqa: E501

        if 'beam_id' in params and params['beam_id'] > 7:  # noqa: E501
            raise ValueError("Invalid value for parameter `beam_id` when calling `set_beam_single_mic`, must be a value less than or equal to `7`")  # noqa: E501
        if 'beam_id' in params and params['beam_id'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `beam_id` when calling `set_beam_single_mic`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'mic_id' in params and params['mic_id'] > 49:  # noqa: E501
            raise ValueError("Invalid value for parameter `mic_id` when calling `set_beam_single_mic`, must be a value less than or equal to `49`")  # noqa: E501
        if 'mic_id' in params and params['mic_id'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `mic_id` when calling `set_beam_single_mic`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'beam_id' in params:
            query_params.append(('beam_id', params['beam_id']))  # noqa: E501
        if 'mic_id' in params:
            query_params.append(('mic_id', params['mic_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/beamforming/set_beam_single_mic', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='bool',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_network_configuration(self, network_configuration, **kwargs):  # noqa: E501
        """Sets the network configuration of the device  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_network_configuration(network_configuration, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NetworkConfiguration network_configuration: the network configuration to set (required)
        :return: NetworkConfiguration
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_network_configuration_with_http_info(network_configuration, **kwargs)  # noqa: E501
        else:
            (data) = self.set_network_configuration_with_http_info(network_configuration, **kwargs)  # noqa: E501
            return data

    def set_network_configuration_with_http_info(self, network_configuration, **kwargs):  # noqa: E501
        """Sets the network configuration of the device  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_network_configuration_with_http_info(network_configuration, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NetworkConfiguration network_configuration: the network configuration to set (required)
        :return: NetworkConfiguration
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['network_configuration']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_network_configuration" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'network_configuration' is set
        if ('network_configuration' not in params or
                params['network_configuration'] is None):
            raise ValueError("Missing the required parameter `network_configuration` when calling `set_network_configuration`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'network_configuration' in params:
            body_params = params['network_configuration']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/set_network_configuration', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NetworkConfiguration',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_state(self, beam_state, **kwargs):  # noqa: E501
        """Sets the beamformer state (delays, gains, microphones enabled)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_state(beam_state, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BeamformerState beam_state: the state of the beam under control (required)
        :param int beam_id: the beam to control. Should be a number between 0 and 7
        :return: BeamformerState
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_state_with_http_info(beam_state, **kwargs)  # noqa: E501
        else:
            (data) = self.set_state_with_http_info(beam_state, **kwargs)  # noqa: E501
            return data

    def set_state_with_http_info(self, beam_state, **kwargs):  # noqa: E501
        """Sets the beamformer state (delays, gains, microphones enabled)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_state_with_http_info(beam_state, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BeamformerState beam_state: the state of the beam under control (required)
        :param int beam_id: the beam to control. Should be a number between 0 and 7
        :return: BeamformerState
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['beam_state', 'beam_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'beam_state' is set
        if ('beam_state' not in params or
                params['beam_state'] is None):
            raise ValueError("Missing the required parameter `beam_state` when calling `set_state`")  # noqa: E501

        if 'beam_id' in params and params['beam_id'] > 7:  # noqa: E501
            raise ValueError("Invalid value for parameter `beam_id` when calling `set_state`, must be a value less than or equal to `7`")  # noqa: E501
        if 'beam_id' in params and params['beam_id'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `beam_id` when calling `set_state`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'beam_id' in params:
            query_params.append(('beam_id', params['beam_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'beam_state' in params:
            body_params = params['beam_state']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/beamforming/set_state', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BeamformerState',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def start_streamer(self, **kwargs):  # noqa: E501
        """start the streaming service on the device  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.start_streamer(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.start_streamer_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.start_streamer_with_http_info(**kwargs)  # noqa: E501
            return data

    def start_streamer_with_http_info(self, **kwargs):  # noqa: E501
        """start the streaming service on the device  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.start_streamer_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method start_streamer" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/start_streaming', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def stop_streamer(self, **kwargs):  # noqa: E501
        """stop the streaming service on the device  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stop_streamer(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.stop_streamer_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.stop_streamer_with_http_info(**kwargs)  # noqa: E501
            return data

    def stop_streamer_with_http_info(self, **kwargs):  # noqa: E501
        """stop the streaming service on the device  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stop_streamer_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stop_streamer" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/stop_streaming', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_firmware(self, **kwargs):  # noqa: E501
        """trigger a firmware update on the device  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_firmware(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_firmware_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.update_firmware_with_http_info(**kwargs)  # noqa: E501
            return data

    def update_firmware_with_http_info(self, **kwargs):  # noqa: E501
        """trigger a firmware update on the device  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_firmware_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_firmware" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/update_firmware', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
