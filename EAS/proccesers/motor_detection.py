# -*- coding: utf-8 -*-
"""motor_detection.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tHb_GTLbeRwngnIrsSIZt_lAvYIfiInK
"""

import numpy as np
import librosa
from scipy.signal import correlate
from scipy.signal import find_peaks

def pitch_detect_corr(signal: np.ndarray, sampling_freq: int) -> int: ## Side function, input: audio signal and sampling rate, output: float variable of the signal's pitch

  lowest_pitch_f =  20 # in Hz
  highest_pitch_f =  650 # in Hz
  sig_ac = correlate(signal , signal)[len(signal):]
  sig_ac = sig_ac[sampling_freq//highest_pitch_f:sampling_freq//lowest_pitch_f]

  peaks, _ = find_peaks(sig_ac, prominence = 0.1 * np.max(sig_ac))

  if len(peaks) < 1:
    return 0

  if len(peaks) == 1:
    pitch_period = peaks[np.argmax(sig_ac[peaks])] + sampling_freq//highest_pitch_f + 1
  else:
    pitch_period = np.mean(np.diff(peaks)) + 1

  return pitch_period # in units of samples


def motor_detection(signal: np.ndarray, sampling_freq: int): ## Main function, input: audio signal and sampling rate, output: boolean variable of whether the audio is of a motor

  ## IMPORTANT DISCLAIMER ##
  ## the algorithm requires the input signal to be of duration longer than the local variable detect_sec (default value of 2 seconds)

  detect_sec = 1 # minimum duration for which the audio has to be similar to a motor to be detected
  patience_per = 0.3 # percentage of outlier samples we allow (meaning we require at least 1-patience_per of samples to be in a the error_bar_hz range)
  error_bar_hz = 100 # the error range in Hz we allow for inlier samples
  pitch_low_limit = 20 # in Hz, lowest legal range for detection
  pitch_high_limit = 650 # in Hz, highest legal range for detection

  window_ms = 0.1 # size in seconds of window for pitch detection
  window_smp = window_ms * sampling_freq # in units of samples
  win_overlap = 0.5

  N = int(len(signal) // (window_smp * (1 - win_overlap))) # number of total windows in signal
  detect_count = int(detect_sec // (window_ms * (1 - win_overlap))) # number of consecutive windows required to be detected as true (including outliers)
  patience_count = int(patience_per * detect_count) # max number of outliers allowed in the detection range for the detection to be true

  # variable initiation
  target_pitch = 0 # the "ongoing pitch"
  pitches = [] # array of pitches for each window
  pitches_on_target = [] # binary array, symbols whether the pitch is an inlier (1), or an outlier (0)

  # main loop
  for i in range(N):

    # get window
    window_start = int(i * window_smp * (1 - win_overlap))
    window_end = int(window_start + window_smp)
    window = signal[window_start:window_end]

    # detect pitch
    window_pitch = pitch_detect_corr(window, sampling_freq) # pitch in unit of samples

    if window_pitch == 0:
      continue # pitch 0 is the default value of the pitch algorithm faling to identify a clear base frequency in the window

    window_pitch_hz = sampling_freq / window_pitch # pitch in unit of Hz

    pitches.append(window_pitch_hz)

    if len(pitches) <= detect_count: # if we did not meet the minimum required number of windows, we would be interested only in updating the "ongoing pitch", but not in making a detection yet

      target_pitch = np.median(pitches)
      pitches_on_target.append(abs(window_pitch_hz - target_pitch) <= error_bar_hz)
      continue

    target_pitch = np.median(pitches[-detect_count:])
    pitches_on_target.append(abs(window_pitch_hz - target_pitch) <= error_bar_hz)

    if np.all(not pitches_on_target[-patience_count:]) or target_pitch < pitch_low_limit or target_pitch > pitch_high_limit: # if the "ongoing pitch" is out of legal range, or there are to many outliers in a row, we would like to reset the detection window
      target_pitch = 0
      pitches = []
      pitches_on_target = []
      continue
    
    #print(f"pitcehs#{np.sum(pitches_on_target[-detect_count:])},patience#{detect_count * (1 - patience_per)}")

    if np.sum(pitches_on_target[-detect_count:]) >= detect_count * (1 - patience_per): # as soon as we meet the requirements for detection we return true
      print("engine")
      return True
  
  print("background")
  return False